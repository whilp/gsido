#!/usr/bin/python2.6
"""%prog [options] [command]

Submit a UI job and connect to it when it begins to run. If <command> is
specified, it is executed on the remote machine. Otherwise, the current shell
($SHELL) is executed.

To connect a UI job that's already running, pass its ClusterId to the '-i'
option. Use the special ID 'any' to automatically select a suitable running job.

By default, %prog will use glexec to switch to the grid user after connecting to
the UI job; pass the '-g' option to disable glexec.

After the connection is terminated, the UI job's temporary directory including
its submit file, log file and any files transferred back from the remote
machine will be removed. To prevent cleanup, pass the '-P' option; since no
temporary directory is created when connecting to an existing job with '-i',
cleanup does not occur in that case, either.
"""

import logging
import os
import sys
import zlib

from base64 import b64encode, b64decode
from collections import namedtuple
from contextlib import contextmanager
from optparse import OptionParser, make_option as Opt
from pwd import getpwuid
from shutil import rmtree
from subprocess import CalledProcessError, Popen, PIPE
from tempfile import mkdtemp
from time import sleep

log = logging.getLogger(__name__)

def main():
    optparser = OptionParser(usage=__doc__, option_list=options)
    (opts, args) = optparser.parse_args()

    verbose = int(opts.verbose)
    if verbose >= 0:
        log.level = max(1, logging.WARNING - (10 * verbose))
        log.addHandler(logging.StreamHandler())

    user = getuser()
    cert = opts.certificate
    if not cert:
        cert = os.environ.get("GLEXEC_CLIENT_CERT",
            os.environ.get("X509_USER_PROXY",
                "/tmp/x509up_u%d" % os.getuid()))

    os.environ["GLEXEC_CLIENT_CERT"] = cert

    return phase(args, **vars(opts))

options = [
    Opt("-v", "--verbose", default=0, help="set logging level to VERBOSE"),

    Opt("-c", "--certificate", default=None, action="store",
        help="use grid certificate or proxy CERTIFICATE"),
    Opt("-p", "--phase", default=None, action="store",
        help="glexec phase; internal"),
]

def phase(args, phase="run", **kwargs):
    """Begin a glexec session.

    Delegates to one of the phase functions (see :data:`phases`) keyed by
    *phase*. *args* and *kwargs* are passed directly to the selected phase
    function.
    """
    log.debug("beginning phase %s", phase)

    fn = phases.get(phase, preglexec)
    return fn(args, **kwargs)

def run(args, env=os.environ, shell="/bin/bash", **kwargs):
    """Executes a shell.

    Uses *shell* if *env* does not contain a SHELL key. If *args* is not empty,
    they will be passed with '-c' to the shell. *kwargs* is ignored.
    """
    shell = [env.get("SHELL", shell)]

    if args:
        shell.append("-c")
    shell.extend(args)

    log.debug("running `%s %s`", shell[0], " ".join(repr(x) for x in shell[1:]))
    return os.execv(shell[0], shell)

def preglexec(args, verbose=0, **kwargs):
    """Prepare the runtime environment for glexec.

    The contents of *args* is appended to the argument list used to re-invoke
    this script with glexec in the 'postglexec' phase. The '-v' option passed
    to this script after glexec is constructed using *verbose*; other *kwargs*
    are currently ignored. Encodes :data:`os.environ` with :func:`envencode`,
    storing the result in the `GLEXEC_ENV` environment variable for later
    restoration.
    """
    if not getexec("glexec"):
        log.critical("could not find glexec")
        return 1

    cert = os.environ.get("GLEXEC_CLIENT_CERT")
    fail = None
    if not os.path.isfile(cert):
        fail = "grid certificate %s is not a file"
    elif not os.access(cert, os.R_OK):
        fail = "cannot read grid certificate %s"

    if fail:
        log.warn(fail, cert)
        return 1

    log.debug("using certificate/proxy %s", cert)

    # https://www.nikhef.nl/pub/projects/grid/gridwiki/index.php/GLExec_Environment_Wrap_and_Unwrap_scripts
    log.debug("preparing environment for glexec")
    env = dict(os.environ.copy())
    env["GLEXEC_ENV"] = envencode(env)
    glexecargs = [sys.executable, getexecp(sys.argv[0]),
        "-v", str(verbose),
        "-p", "postglexec", "--"]
    glexecargs.extend(args)
    log.debug("running `glexec %s`", " ".join(repr(x) for x in glexecargs))
    return os.execvpe("glexec", glexecargs, env)

def postglexec(args, **kwargs):
    """Restore the runtime environment after glexec.

    Decodes the pre-glexec environment encoded in `$GLEXEC_ENV` using
    :func:`envdecode` and uses it to update :data:`os.environ` before calling
    :func:`run`.
    """
    log.debug("restoring environment after glexec")
    env = envdecode(os.environ.pop("GLEXEC_ENV"))
    os.environ.update(env)

    return run(args, **kwargs)

# Glexec phases.
phases = dict(
    preglexec=preglexec,
    postglexec=postglexec,
)

envblacklist = ("HOME", "LOGNAME", "USER", "X509_USER_PROXY", "_")
def envblacklisted(key, blacklist=envblacklist):
    """Return False if *key* should be excluded from the post-glexec environment."""
    return key in envblacklist

def envencode(env):
    """Encode environment dictionary *env*.

    *env* should be a mapping of string keys to string values, like
    :data:`os.environ`. Returns a base64-encoded string suitable for restoration
    with :func:`envdecode`.
    """
    blobs = [b64encode("%s=%s" % (k, v)) for k, v in env.items()
                if not envblacklisted(k)]

    return b64encode(zlib.compress(" ".join(blobs), 9))

def envdecode(env):
    """Decode the encoded environment in string *env*.

    *env* should be a mapping like :data:`os.environ` encoded with
    :func:`envdecode`. Returns the decoded mapping.
    """
    blobs = zlib.decompress(b64decode(env)).split(" ")

    return dict(
        b64decode(blob).split("=", 1) for blob in blobs
    )

def isexec(path):
    """Return True if *path* exists and is an executable file."""
    try:
        return os.path.isfile(path) and os.access(path, os.X_OK)
    except (OSError, IOError):
        return False

def getuser(env=os.environ):
    """Return the name of the current user.

    If the `$CLUSTERUI_USER` environment variable is defined, return that.
    Otherwise, return the name associated with the current UID.
    """
    return env.get("CLUSTERUI_USER", getpwuid(os.getuid())[0])

def getexec(path):
    """Search for *path* among the directories in the `$PATH` environment variable.

    If *path* is an executable file, return it. Otherwise, search each directory
    in $PATH in order, checking for an executable file named *path* in each.
    Return None if no match is found.
    """
    if isexec(path):
        return path
    elif os.path.sep in path:
        return None

    base = os.path.basename(path)
    for dir in os.environ.get("PATH", "").split(os.pathsep):
        path = os.path.join(dir, base)
        if isexec(path):
            return path

def getexecp(path):
    """Return the absolute path to an executable matching *path*.

    See :func:`getexec`.
    """
    return os.path.abspath(getexec(path))

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit()
